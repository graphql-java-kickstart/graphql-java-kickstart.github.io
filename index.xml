<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>GraphQL Java Kickstart</title><link>https://www.graphql-java-kickstart.com/</link><description>Recent content on GraphQL Java Kickstart</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 08 Mar 2016 21:07:13 +0100</lastBuildDate><atom:link href="https://www.graphql-java-kickstart.com/index.xml" rel="self" type="application/rss+xml"/><item><title>Getting started</title><link>https://www.graphql-java-kickstart.com/servlet/getting-started/</link><pubDate>Wed, 07 Nov 2018 00:11:02 +0100</pubDate><guid>https://www.graphql-java-kickstart.com/servlet/getting-started/</guid><description>A working version of this example can be found at https://github.com/graphql-java-kickstart/samples/tree/master/servlet-hello-world.
Build with Gradle First you set up a basic build script. You can use any build system you like, but the code you need to work with Gradle and Maven is included here.
Create a Gradle build file Make sure mavenCentral is among your repositories. The example build script below uses org.gretty to provide a webserver to show a working example.</description></item><item><title>Getting started</title><link>https://www.graphql-java-kickstart.com/spring-boot/getting-started/</link><pubDate>Wed, 07 Nov 2018 00:11:02 +0100</pubDate><guid>https://www.graphql-java-kickstart.com/spring-boot/getting-started/</guid><description>This project requires at least the following version:
Java 8 Spring Boot &amp;gt; 2.x.x (spring-boot-starter-web) Quick start To add graphql-spring-boot to your project and get started quickly, do the following.
Build with Gradle Make sure mavenCentral is amongst your repositories:
repositories { mavenCentral() } Add the respective starter dependencies you want to use:
dependencies { compile &amp;#39;com.graphql-java-kickstart:graphql-spring-boot-starter:7.0.1&amp;#39; compile &amp;#39;com.graphql-java-kickstart:graphiql-spring-boot-starter:7.0.1&amp;#39; compile &amp;#39;com.graphql-java-kickstart:voyager-spring-boot-starter:7.0.1&amp;#39; testCompile &amp;#39;com.graphql-java-kickstart:graphql-spring-boot-starter-test:7.0.1&amp;#39; } Build with Maven Add the respective starter dependencies you want to use:</description></item><item><title>Getting started</title><link>https://www.graphql-java-kickstart.com/tools/getting-started/</link><pubDate>Wed, 07 Nov 2018 00:11:02 +0100</pubDate><guid>https://www.graphql-java-kickstart.com/tools/getting-started/</guid><description>A working Java Spring-Boot application is provided, based off the Star Wars API tests and test data. If you&amp;rsquo;re using Spring Boot, check out the graphql-spring-boot-starter!
A working Kotlin example can be found in the tests.
Quick start To add graphql-java-tools to your project and get started quickly, do the following.
Build with Gradle Make sure mavenCentral is amongst your repositories:
repositories { mavenCentral() } Add the graphql-java-tools dependency:
dependencies { compile &amp;#39;com.</description></item><item><title>Dataloaders</title><link>https://www.graphql-java-kickstart.com/servlet/dataloaders/</link><pubDate>Wed, 07 Nov 2018 00:11:02 +0100</pubDate><guid>https://www.graphql-java-kickstart.com/servlet/dataloaders/</guid><description>It is possible to create context, and consequently dataloaders, in both a request scope and a per query scope by customizing GraphQLContextBuilder and selecting the appropriate ContextSetting with the provided GraphQLConfiguration. A new DataLoaderRegistry should be created in each call to the GraphQLContextBuilder, and the servlet will call the builder at the appropriate times. For example:
public class CustomGraphQLContextBuilder implements GraphQLServletContextBuilder { private final DataLoader userDataLoader; public CustomGraphQLContextBuilder(DataLoader userDataLoader) { this.</description></item><item><title>Defining a schema</title><link>https://www.graphql-java-kickstart.com/tools/schema-definition/</link><pubDate>Wed, 07 Nov 2018 00:11:02 +0100</pubDate><guid>https://www.graphql-java-kickstart.com/tools/schema-definition/</guid><description>A GraphQL schema can be given either as raw strings:
// My application class SchemaParser.newParser() .schemaString(&amp;#34;Query { }&amp;#34;) or as files on the classpath:
// My application class SchemaParser.newParser() .file(&amp;#34;my-schema.graphqls&amp;#34;) // my-schema.graphqls Query { } Multiple sources will be concatenated together in the order given, allowing you to modularize your schema if desired.
Resolvers and Data Classes GraphQL Java Tools maps fields on your GraphQL objects to methods and properties on your java objects.</description></item><item><title>Servlet Listener</title><link>https://www.graphql-java-kickstart.com/servlet/servlet-listener/</link><pubDate>Fri, 15 May 2020 09:28:02 +0100</pubDate><guid>https://www.graphql-java-kickstart.com/servlet/servlet-listener/</guid><description>The GraphQL Servlet library allows you to add a Servlet Listener for listening to the GraphQL request. It provides hooks into the servlet request execution (success, error, and finally):
public class MyServlet extends GraphQLHttpServlet { @Override protected GraphQLConfiguration getConfiguration() { return GraphQLConfiguration.with(createSchema()) .with(queryInvoker) .with(Arrays.asList(listener)) .build(); } } Instrumentation The Servlet Listener listens to the servlet request, but not to the GraphQL query execution. If you want to listen to that you should use the Instrumentation provided by GraphQL Java.</description></item><item><title>Schema parser options</title><link>https://www.graphql-java-kickstart.com/tools/schema-parser-options/</link><pubDate>Wed, 07 Nov 2018 00:11:02 +0100</pubDate><guid>https://www.graphql-java-kickstart.com/tools/schema-parser-options/</guid><description>For advanced use-cases, the schema parser can be tweaked to suit your needs. Use SchemaParserOptions.newBuilder() to build an options object to pass to the parser.
Options:
genericWrappers: Allows defining your own generic classes that should be unwrapped when matching Java types to GraphQL types. You must supply the class and the index (zero-indexed) of the wrapped generic type. For example: If you want to unwrap type argument T of Future&amp;lt;T&amp;gt;, you must pass Future.</description></item><item><title>Relay</title><link>https://www.graphql-java-kickstart.com/tools/relay/</link><pubDate>Wed, 07 Nov 2018 00:11:02 +0100</pubDate><guid>https://www.graphql-java-kickstart.com/tools/relay/</guid><description>Relay requires quite some boilerplate type definitions to be defined. They are all the same apart from type of the node the Relay connection targets. This results in schemas with a lot of duplication, like the following:
type Query { users(first: Int, after: String): UserConnection organizations(first: Int, after: String): OrganizationConnection } type UserConnection { edges: [UserEdge] pageInfo: PageInfo } type UserEdge { cursor: String node: User } type PageInfo { hasPreviousPage: Boolean!</description></item><item><title>Type Definition Factory</title><link>https://www.graphql-java-kickstart.com/spring-boot/type-definition-factory/</link><pubDate>Wed, 07 Nov 2018 00:11:02 +0100</pubDate><guid>https://www.graphql-java-kickstart.com/spring-boot/type-definition-factory/</guid><description>The Type Definition Factory has been added with to be able to dynamically add type definitions to the schema instead of having to define them manually in the SDL. There are a couple of use cases where the types that have to be defined are very much alike and only certain parts are different. For example the connection and edge types used by Relay. Since generics isn&amp;rsquo;t supported in the definition language this type definition factory has been added.</description></item><item><title>Type Definition Factory</title><link>https://www.graphql-java-kickstart.com/tools/type-definition-factory/</link><pubDate>Wed, 07 Nov 2018 00:11:02 +0100</pubDate><guid>https://www.graphql-java-kickstart.com/tools/type-definition-factory/</guid><description>The Type Definition Factory has been added with to be able to dynamically add type definitions to the schema instead of having to define them manually in the SDL. There are a couple of use cases where the types that have to be defined are very much alike and only certain parts are different. For example the connection and edge types used by Relay. Since generics isn&amp;rsquo;t supported in the definition language this type definition factory has been added.</description></item><item><title>Directives</title><link>https://www.graphql-java-kickstart.com/spring-boot/directives/</link><pubDate>Wed, 07 Nov 2018 00:11:02 +0100</pubDate><guid>https://www.graphql-java-kickstart.com/spring-boot/directives/</guid><description>See Schema Directives for a detailed explanation about directives including examples on how to define them in the SDL and to create the required classes.
To add your custom SchemaDirectiveWiring to graphql-spring-boot create a bean of type SchemaDirective to have it automatically passed along to the SchemaParser
SchemaDirective.create(&amp;quot;uppercase&amp;quot;, new UppercaseDirective()) Basic usage Let&amp;rsquo;s say you defined a custom directive to make text uppercase in a resource schema.graphqls:
directive @uppercase on FIELD_DEFINITION type Query { hello: String @uppercase } And the actual implementation is the following:</description></item><item><title>Directives</title><link>https://www.graphql-java-kickstart.com/tools/directives/</link><pubDate>Wed, 07 Nov 2018 00:11:02 +0100</pubDate><guid>https://www.graphql-java-kickstart.com/tools/directives/</guid><description>See Schema Directives for a detailed explanation about directives including examples on how to define them in the SDL and to create the required classes.
To add your custom SchemaDirectiveWiring to graphql-java-tools pass it along when creating the SchemaParser using
SchemaParser.newParser().directive(&amp;quot;name&amp;quot;, new MySchemaDirectiveWiring()).build() Basic usage Let&amp;rsquo;s say you defined a custom directive to make text uppercase in a resource schema.graphqls:
directive @uppercase on FIELD_DEFINITION type Query { hello: String @uppercase } And the actual implementation is the following:</description></item><item><title>OSGi</title><link>https://www.graphql-java-kickstart.com/servlet/osgi/</link><pubDate>Fri, 15 May 2020 09:28:02 +0100</pubDate><guid>https://www.graphql-java-kickstart.com/servlet/osgi/</guid><description>The OsgiGraphQLHttpServlet uses a &amp;ldquo;provider&amp;rdquo; model to supply the servlet with the required objects:
GraphQLQueryProvider: Provides query fields to the GraphQL schema. GraphQLMutationProvider: Provides mutation fields to the GraphQL schema. GraphQLTypesProvider: Provides type information to the GraphQL schema. ExecutionStrategyProvider: Provides an execution strategy for running each query. GraphQLContextBuilder: Builds a context for running each query. Examples You can now find some example on how to use graphql-java-servlet.
Requirements The OSGi examples use Maven as a build tool because it requires plugins that are not (yet) available for Gradle.</description></item></channel></rss>